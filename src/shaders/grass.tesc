#version 450
#extension GL_ARB_separate_shader_objects : enable

#define OUTERTESSLEVEL 10
#define INNERTESSLEVEL 10

layout(vertices = 1) out;   // We want tessellation points to be generated for each blade just once, hence we have set layout vertices to 1, which denotes number of blades in output patch

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

/*
The Tessellation control shader DOES NOT determine the positions of the tessellated vertices generated.
If the tessellation patch type is quads for example, imagine that TCS will generate a number of tessellated points equal to what a quad would have, once per blade in this case, since layout specifies output patch size as 1 (number of blades per patch generated in the output - NOT number of vertices per patch).
Note that these points are not "positioned" anywhere specifically along a quad or so, just generated. A tessellator in the next step would appropriately group it together.
These points are saved in gl_TessCoords as a 2D array (imagine iterating over points in a tessellated quad).
The Evaluation shader then reads these points and appropriately positions them to tessellate each blade along a grass blade curve.
*/


/*
Notice that the primitive generation is not affected by the user-defined outputs of the TCS (or vertex shader if no TCS is active), the TCS's output patch size, or any per-patch TCS outputs besides the tessellation levels. The primitive generation part of the tessellation stage is completely blind to the actual vertex coordinates and other patch data.
The purpose of the primitive generation system is to determine how many vertices to generate, in which order to generate them, and what kind of primitives to build out of them. The actual per-vertex data for these vertices, such as position, color, etc., is to be generated by the TES, based on information provided by the primitive generator.
Because of this dichotomy, the primitive generator operates on what could be considered an "abstract patch". It doesn't look at the patch output from the TCS; it thinks only in terms of tessellating an abstract quad, triangle, or "isoline" block.
Ref: https://www.khronos.org/opengl/wiki/Tessellation#Tessellation_primitive_generation
*/


// TODO: Declare tessellation control shader inputs and outputs

layout(location = 0) in vec4 tcs_v1[];
layout(location = 1) in vec4 tcs_v2[];
layout(location = 2) in vec4 tcs_up[];

layout(location = 0) out vec4 tes_v1[];
layout(location = 1) out vec4 tes_v2[];
layout(location = 2) out vec4 tes_up[];

in gl_PerVertex
{
  vec4 gl_Position;
} gl_in[gl_MaxPatchVertices];

void main() {
	// Don't move the origin location of the patch
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    tes_v1[gl_InvocationID] = tcs_v1[gl_InvocationID];
    tes_v2[gl_InvocationID] = tcs_v2[gl_InvocationID];
    tes_up[gl_InvocationID] = tcs_up[gl_InvocationID];

	// TODO: Write any shader outputs

	// TODO: Set level of tesselation
    gl_TessLevelInner[0] = INNERTESSLEVEL;
    gl_TessLevelInner[1] = INNERTESSLEVEL;
    gl_TessLevelOuter[0] = OUTERTESSLEVEL;
    gl_TessLevelOuter[1] = OUTERTESSLEVEL;
    gl_TessLevelOuter[2] = OUTERTESSLEVEL;
    gl_TessLevelOuter[3] = OUTERTESSLEVEL;
}
